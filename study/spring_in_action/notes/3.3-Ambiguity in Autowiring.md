
# **自动装配过程中的模糊性问题**

前面介绍过，使用自动装配过程中，如果Spring在Application Context中找到了多个满足要求的bean，Spring将无法选择，从而带来了模糊性问题。

例子：

``` java

@Autowired
public void setDessert(Dessert dessert) {
    this.dessert = dessert;
}

```

``` java

@Component
public class Cake implements Dessert { ... }

@Component
public class Cookies implements Dessert { ... }

@Component
public class IceCream implements Dessert { ... }

```

解析: 这里使用的是属性注入的方式来注入一个Dessert类型的对象，由于 setDessert的参数是Dessert类型的变量，它可以接受任何实现了该接口的对象，而在实际过程中，我们定义三个这种接口的实现类，在装配的时候，Spring会找到三个满足要求的bean，Spring将无法选择使用哪一个bean进行注入，从而会抛出NoUniqueBeanDefinitionException异常，类型栈信息如下：

``` java

nested exception is
org.springframework.beans.factory.NoUniqueBeanDefinitionException:
No qualifying bean of type [com.desserteater.Dessert] is defined:

expected single matching bean but found 3: cake,cookies,iceCream

```

## **解决方法**

有两种解决方法：

- 使用primary将其中一个bean声明为primary

- 使用qualifier帮助Spring将选择缩小到某个bean

### 一、 **使用primary**

- 在java中进行配置

如果使用的是组件扫描，采用下面这种形式

``` java

@Component
@Primary
public class IceCream implements Dessert { ... }

```

如果使用的是显示的Java配置，使用下面这种形式：

``` java

@Bean
@Primary
public Dessert iceCream() {
    return new IceCream();
}

```

- 在XML中进行配置

    <bean id="iceCream" class="com.desserteater.IceCream" **primary="true"** />

**强调**：尽管使用primary可以将某个bean设置为首选注入对象，但是使用的时候，对同种父类型的注入对象，同样不能使用多个primary。

### 二、**使用qualifier**

